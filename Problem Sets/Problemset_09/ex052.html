
<!-- saved from url=(0101)https://mooshak.dcc.fc.up.pt/~pi/cgi-bin/execute/9415981350194654?view+PI052_Polish_Inverted_Notation -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<link rel="stylesheet" href="./base.css" type="text/css">
</head>
<body bgcolor="white">
<center>
<table cellpadding="20" width="100%">
<tbody><tr>
<td id="Base">
  
    
    <title>[PI052] - Reverse Polish Notation</title>
<meta name="description" content="[PI052] - Reverse Polish Notation">
<link rel="StyleSheet" href="./style.css" type="text/css">

  



<p id="en"><img src="./9415981350194654" height="20"> <b>English version</b> | [<a href="https://mooshak.dcc.fc.up.pt/~pi/cgi-bin/execute/9415981350194654?view+PI052_Polish_Inverted_Notation#pt">ver versão em português</a>]</p>

<h2>[PI052] - Reverse Polish Notation</h2>


<h3>The Problem</h3>

<p><img align="right" src="./9415981350194654(1)" height="600" alt="" border="0">
Back in elementary school, you learned that different arithmetic operators have different precedences.
This is true in every country. For example, in English, there's a mnemonic to remember the order:
<i><b>"Please Excuse My Dear Aunt Sally"</b></i> – representing the order:
<b>P</b>arentheses, <b>E</b>xponents, <b>M</b>ultiplication, <b>D</b>ivision, <b>A</b>ddition, and <b>S</b>ubtraction.</p>

<p>For instance, the expression:</p>
<pre>1 + 2 * 3 = ?</pre>
<p>results in <tt>7</tt> because multiplication takes precedence over addition.</p>

<p>If we wanted to perform the addition first, we would need parentheses:</p>
<pre>(1 + 2) * 3 = ?</pre>

<p>However, in the early days of electronic calculators, parsing expressions with precedence and parentheses proved complicated.</p>

<p>To address this, the Polish mathematician <b>Jan Łukasiewicz</b> introduced a notation in the 1920s that made parentheses unnecessary,
ensuring operations would be evaluated in the desired order. In his system, operators are written <b>before</b> their operands.</p>

<p>Later, in the 1950s, computer scientist <b>Charles L. Hamblin</b> proposed placing operators <b>after</b> the operands instead. This variant,
which became very popular due to its ease of implementation using stacks, is known as
<b>Reverse Polish Notation (RPN)</b>, or <i>postfix notation</i>. In RPN, even complex expressions can be written without parentheses.</p>

<br>

<table class="main">
<tbody><tr>
    <th>Infix Notation</th>
    <th>Reverse Polish Notation (RPN)</th>
</tr>
<tr>
    <td>1 + 1</td>
    <td>1 1 +</td>
</tr>
<tr>
    <td>3 * (4 + 5)</td>
    <td>3 4 5 + *</td>
</tr>
<tr>
    <td>3 + 4 * 5</td>
    <td>3 4 5 * +</td>
</tr>
</tbody></table>

<p>Your task is to write a program that evaluates expressions written in RPN. A standard evaluation algorithm works as follows:</p>

<ul>
  <li>Create an empty stack.</li>
  <li>Process the expression from left to right:</li>
  <ul>
    <li>If the element is a number, push it onto the stack.</li>
    <li>If it is an operator, pop the top two numbers from the stack, apply the operator, and push the result back onto the stack.</li>
  </ul>
  <li>At the end, there should be exactly one value on the stack — the result of the expression.</li>
  <li>If at any point this rule is violated (e.g., trying to pop from an empty stack), the expression is considered invalid.</li>
</ul>

<h3>Input</h3>

<p>The first line contains an integer <b>N</b>, the number of expressions to evaluate.</p>

<p>The following <b>N</b> lines each contain a single RPN expression, consisting of:</p>
<ul>
  <li>Integers (positive or negative, always valid as stand-alone tokens)</li>
  <li>Operators: <tt>+</tt>, <tt>-</tt>, <tt>*</tt>, <tt>/</tt></li>
</ul>


<p>You may assume that:
</p><ul>
  <li>All numbers are integers.</li>
  <li>Intermediate results are always integers.</li>
  <li>Only the four basic operations are used.</li>
  <li>The length of an expression, in characters, is less than 10,000.</li> 
</ul>

<h3>Output</h3>

<p>For each expression, print a single line:</p>
<ul>
  <li>The result of the expression, if it is valid.</li>
  <li><tt><b>Expressao Incorreta</b> (<i>Incorrect Expression</i></tt>, if the expression is malformed (e.g., stack underflow, leftover items, or division by zero).</li>
</ul>

<h3>Exemplo de input/output</h3>

<table class="main" cellpadding="4" border="1">
<tbody><tr>
       <th>Input</th>
       <th>Output</th>
</tr>
<tr>
       <td valign="top" class="left">
<pre>6
1 1 +
3 4 5 + *
3 4 5 * +
1 +
1 1 1 +
2 3 8 2 / - 1 + *</pre>
	   </td>
       <td valign="top" class="left">
<pre>2
27
23
Expressao Incorreta
Expressao Incorreta
0<pre>	   </pre></pre></td>
</tr>
</tbody></table>


<hr size="2">

<p id="pt"><img src="./9415981350194654(2)" height="20"> <b>Versão em Português</b> | [<a href="https://mooshak.dcc.fc.up.pt/~pi/cgi-bin/execute/9415981350194654?view+PI052_Polish_Inverted_Notation#en">see english version</a>]</p>

<h2>PI052 - Notação Polaca Invertida</h2>

<hr>

<h3>O problema</h3>

<p><img align="right" src="./9415981350194654(1)" height="600" alt="" border="0">
Quando andaste na escola primária, aprendeste que os diferentes operadores aritméticos têm diferentes precedências.
Isso acontece em todos os países, e por exemplo os ingleses usam a mnemónica: <i>"<b>P</b>lease <b>E</b>xcuse <b>M</b>y <b>D</b>ear <b>A</b>unt <b>S</b>ally"</i>, que
indica a ordem dos operadores (<b>P</b>arênteses, <b>E</b>xponenciação, <b>M</b>ultiplicação, <b>D</b>ivisão, <b>A</b>dição, <b>S</b>ubtração).

</p><p>Por exemplo, a expressão:
</p><pre>1 + 2 x 3 = ?</pre>
dá como resultado <tt>7</tt>, pois o operador multiplicação tem precedência.

<p>Se quisermos avaliar primeiro a soma a expressão tem de ser:
</p><pre>(1 + 2) x 3 = ?</pre>
No entanto, nos tempos iniciais das calculadoras electrónicas, revelou-se complicado analisar
este tipo de expressões.

<p>Por isso mesmo, em 1920, o matemático polaco <b>Jan Lukasiewicz</b> criou uma notação que
tornava desnecessário o uso de parênteses, garantindo sempre que as operações eram efectuadas como
desejado. A notação consistia basicamente em escrever os operadores antes dos números e não no meio deles.

</p><p>Já em 1950, o <i>computer scientist</i> <b>Charles L. Hamblin</b> propôs um esquema onde os operadores
apareciam a seguir aos números, em vez de ser antes. Esta notação acabou por ser muito usada, devido entre
outras coisas à sua fácil implementação num sistema automático usando uma pilha, e ficou conhecida como
<b>Notação Polaca Invertida (RPN)</b> (ou <i>postfix</i>). Em RPN, uma expressão arbitrariamente
complexa pode ser escrita sem o uso de parênteses.<br>&nbsp;

<table class="main">
<tbody><tr>
       <th>Notação Normal</th>
       <th>Notação Polaca Invertida (RPN)</th>
</tr>
<tr>
       <td>1 + 1</td>
       <td>1 1 +</td>
</tr>
<tr>
       <td>3 * (4 + 5)</td>
       <td>3 4 5 + *</td>
</tr>
<tr>
       <td>3 + 4 * 5</td>
       <td>3 4 5 * +</td>
</tr>
</tbody></table>

</p><p>A tua tarefa é criar um programa capaz de calcular o valor final de expressões dadas em RPN, sabendo que
um algoritmo para as analisar é:

</p><ul>
  <li>Criar uma pilha 
  </li><li>Ir da esquerda para a direita lendo elemento a elemento e:
  <ul>
    <li>Se o elemento for um número, inseri-lo na pilha
	</li><li>Se for um operador, retirar dois valores da pilha, aplicar esse operador, e inserir o resultado na pilha
  </li></ul>
  </li><li>No final, fica apenas um valor na pilha, que é o resultado da expressão
  </li><li>Se a pilha não corresponder a alguma das coisas que foi dita atrás (por exemplo, ficar vazia), então a expressão é incorrecta.
</li></ul>

<h3>Input</h3>

<p>A primeira linha contém um número <b>N</b>, indicando o número de expressões a analisar.
</p><p>As seguintes <b>N</b> linhas contêm expressões RPN, contendo
</p><ul>
  <li> Dígitos, representando números inteiro
  </li><li> Caracteres, representando operações (+, -, * , /)
</li></ul>
<p>Podes assumir que os números são sempre inteiros, que os cálculos intermédios vão dar sempre números
inteiros, e que só aparecem os quatro tipos básicos de operações atrás citados. O comprimento de uma expressão não excede os 10,000 caracteres.
 
</p><h3>Output</h3>

<p>Uma linha para cada expressão, indicando o resultado final caso a expressão seja correcta,
ou <tt><b>Expressao Incorreta</b></tt>, caso contrário.

</p><h3>Exemplo de input/output</h3>

<table class="main" cellpadding="4" border="1">
<tbody><tr>
       <th>Input</th>
       <th>Output</th>
</tr>
<tr>
       <td valign="top" class="left">
<pre>6
1 1 +
3 4 5 + *
3 4 5 * +
1 +
1 1 1 +
2 3 8 2 / - 1 + *</pre>
	   </td>
       <td valign="top" class="left">
<pre>2
27
23
Expressao Incorreta
Expressao Incorreta
0<pre>	   </pre></pre></td>
</tr>
</tbody></table>

  
<hr size="2">

<p align="center">Programação Imperativa (CC1003)<br>
DCC/FCUP - Faculdade de Ciências da Universidade do Porto</p>




</td>
</tr>
</tbody></table>
</center>


</body></html>